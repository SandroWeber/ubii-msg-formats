// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SESSION_UBII_SESSIONS_H_
#define FLATBUFFERS_GENERATED_SESSION_UBII_SESSIONS_H_

#include "flatbuffers/flatbuffers.h"

#include "topicDemux_generated.h"
#include "topicMux_generated.h"
#include "interaction_generated.h"
#include "ioFormat_generated.h"
#include "interactionInputMapping_generated.h"
#include "interactionOutputMapping_generated.h"
#include "ioMapping_generated.h"

namespace ubii {
namespace sessions {

struct Session;
struct SessionBuilder;
struct SessionT;

enum ProcessMode {
  ProcessMode_CYCLE_INTERACTIONS = 0,
  ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES = 1,
  ProcessMode_MIN = ProcessMode_CYCLE_INTERACTIONS,
  ProcessMode_MAX = ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES
};

inline const ProcessMode (&EnumValuesProcessMode())[2] {
  static const ProcessMode values[] = {
    ProcessMode_CYCLE_INTERACTIONS,
    ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES
  };
  return values;
}

inline const char * const *EnumNamesProcessMode() {
  static const char * const names[3] = {
    "CYCLE_INTERACTIONS",
    "INDIVIDUAL_PROCESS_FREQUENCIES",
    nullptr
  };
  return names;
}

inline const char *EnumNameProcessMode(ProcessMode e) {
  if (flatbuffers::IsOutRange(e, ProcessMode_CYCLE_INTERACTIONS, ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProcessMode()[index];
}

enum SessionStatus {
  SessionStatus_CREATED = 0,
  SessionStatus_RUNNING = 1,
  SessionStatus_PAUSED = 2,
  SessionStatus_STOPPED = 3,
  SessionStatus_MIN = SessionStatus_CREATED,
  SessionStatus_MAX = SessionStatus_STOPPED
};

inline const SessionStatus (&EnumValuesSessionStatus())[4] {
  static const SessionStatus values[] = {
    SessionStatus_CREATED,
    SessionStatus_RUNNING,
    SessionStatus_PAUSED,
    SessionStatus_STOPPED
  };
  return values;
}

inline const char * const *EnumNamesSessionStatus() {
  static const char * const names[5] = {
    "CREATED",
    "RUNNING",
    "PAUSED",
    "STOPPED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSessionStatus(SessionStatus e) {
  if (flatbuffers::IsOutRange(e, SessionStatus_CREATED, SessionStatus_STOPPED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSessionStatus()[index];
}

struct SessionT : public flatbuffers::NativeTable {
  typedef Session TableType;
  std::string id;
  std::string name;
  std::vector<std::string> authors;
  std::vector<std::string> tags;
  std::string description;
  ubii::sessions::ProcessMode process_mode;
  ubii::sessions::SessionStatus status;
  std::vector<std::unique_ptr<ubii::interactions::InteractionT>> interactions;
  std::vector<std::unique_ptr<ubii::sessions::IOMappingT>> io_mappings;
  SessionT()
      : process_mode(ubii::sessions::ProcessMode_CYCLE_INTERACTIONS),
        status(ubii::sessions::SessionStatus_CREATED) {
  }
};

struct Session FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SessionT NativeTableType;
  typedef SessionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_AUTHORS = 8,
    VT_TAGS = 10,
    VT_DESCRIPTION = 12,
    VT_PROCESS_MODE = 14,
    VT_STATUS = 16,
    VT_INTERACTIONS = 18,
    VT_IO_MAPPINGS = 20
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *authors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_AUTHORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  ubii::sessions::ProcessMode process_mode() const {
    return static_cast<ubii::sessions::ProcessMode>(GetField<int8_t>(VT_PROCESS_MODE, 0));
  }
  ubii::sessions::SessionStatus status() const {
    return static_cast<ubii::sessions::SessionStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>> *interactions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>> *>(VT_INTERACTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ubii::sessions::IOMapping>> *io_mappings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ubii::sessions::IOMapping>> *>(VT_IO_MAPPINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_AUTHORS) &&
           verifier.VerifyVector(authors()) &&
           verifier.VerifyVectorOfStrings(authors()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<int8_t>(verifier, VT_PROCESS_MODE) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_INTERACTIONS) &&
           verifier.VerifyVector(interactions()) &&
           verifier.VerifyVectorOfTables(interactions()) &&
           VerifyOffset(verifier, VT_IO_MAPPINGS) &&
           verifier.VerifyVector(io_mappings()) &&
           verifier.VerifyVectorOfTables(io_mappings()) &&
           verifier.EndTable();
  }
  SessionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SessionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Session> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SessionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SessionBuilder {
  typedef Session Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Session::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Session::VT_NAME, name);
  }
  void add_authors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> authors) {
    fbb_.AddOffset(Session::VT_AUTHORS, authors);
  }
  void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
    fbb_.AddOffset(Session::VT_TAGS, tags);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Session::VT_DESCRIPTION, description);
  }
  void add_process_mode(ubii::sessions::ProcessMode process_mode) {
    fbb_.AddElement<int8_t>(Session::VT_PROCESS_MODE, static_cast<int8_t>(process_mode), 0);
  }
  void add_status(ubii::sessions::SessionStatus status) {
    fbb_.AddElement<int8_t>(Session::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_interactions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>>> interactions) {
    fbb_.AddOffset(Session::VT_INTERACTIONS, interactions);
  }
  void add_io_mappings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::sessions::IOMapping>>> io_mappings) {
    fbb_.AddOffset(Session::VT_IO_MAPPINGS, io_mappings);
  }
  explicit SessionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SessionBuilder &operator=(const SessionBuilder &);
  flatbuffers::Offset<Session> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Session>(end);
    return o;
  }
};

inline flatbuffers::Offset<Session> CreateSession(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> authors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    ubii::sessions::ProcessMode process_mode = ubii::sessions::ProcessMode_CYCLE_INTERACTIONS,
    ubii::sessions::SessionStatus status = ubii::sessions::SessionStatus_CREATED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>>> interactions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::sessions::IOMapping>>> io_mappings = 0) {
  SessionBuilder builder_(_fbb);
  builder_.add_io_mappings(io_mappings);
  builder_.add_interactions(interactions);
  builder_.add_description(description);
  builder_.add_tags(tags);
  builder_.add_authors(authors);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_status(status);
  builder_.add_process_mode(process_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Session> CreateSessionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *authors = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tags = nullptr,
    const char *description = nullptr,
    ubii::sessions::ProcessMode process_mode = ubii::sessions::ProcessMode_CYCLE_INTERACTIONS,
    ubii::sessions::SessionStatus status = ubii::sessions::SessionStatus_CREATED,
    const std::vector<flatbuffers::Offset<ubii::interactions::Interaction>> *interactions = nullptr,
    const std::vector<flatbuffers::Offset<ubii::sessions::IOMapping>> *io_mappings = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto authors__ = authors ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*authors) : 0;
  auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto interactions__ = interactions ? _fbb.CreateVector<flatbuffers::Offset<ubii::interactions::Interaction>>(*interactions) : 0;
  auto io_mappings__ = io_mappings ? _fbb.CreateVector<flatbuffers::Offset<ubii::sessions::IOMapping>>(*io_mappings) : 0;
  return ubii::sessions::CreateSession(
      _fbb,
      id__,
      name__,
      authors__,
      tags__,
      description__,
      process_mode,
      status,
      interactions__,
      io_mappings__);
}

flatbuffers::Offset<Session> CreateSession(flatbuffers::FlatBufferBuilder &_fbb, const SessionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SessionT *Session::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<ubii::sessions::SessionT> _o = std::unique_ptr<ubii::sessions::SessionT>(new SessionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Session::UnPackTo(SessionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = authors(); if (_e) { _o->authors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->authors[_i] = _e->Get(_i)->str(); } } }
  { auto _e = tags(); if (_e) { _o->tags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tags[_i] = _e->Get(_i)->str(); } } }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = process_mode(); _o->process_mode = _e; }
  { auto _e = status(); _o->status = _e; }
  { auto _e = interactions(); if (_e) { _o->interactions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->interactions[_i] = std::unique_ptr<ubii::interactions::InteractionT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = io_mappings(); if (_e) { _o->io_mappings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->io_mappings[_i] = std::unique_ptr<ubii::sessions::IOMappingT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Session> Session::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SessionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSession(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Session> CreateSession(flatbuffers::FlatBufferBuilder &_fbb, const SessionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SessionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _authors = _o->authors.size() ? _fbb.CreateVectorOfStrings(_o->authors) : 0;
  auto _tags = _o->tags.size() ? _fbb.CreateVectorOfStrings(_o->tags) : 0;
  auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
  auto _process_mode = _o->process_mode;
  auto _status = _o->status;
  auto _interactions = _o->interactions.size() ? _fbb.CreateVector<flatbuffers::Offset<ubii::interactions::Interaction>> (_o->interactions.size(), [](size_t i, _VectorArgs *__va) { return CreateInteraction(*__va->__fbb, __va->__o->interactions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _io_mappings = _o->io_mappings.size() ? _fbb.CreateVector<flatbuffers::Offset<ubii::sessions::IOMapping>> (_o->io_mappings.size(), [](size_t i, _VectorArgs *__va) { return CreateIOMapping(*__va->__fbb, __va->__o->io_mappings[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ubii::sessions::CreateSession(
      _fbb,
      _id,
      _name,
      _authors,
      _tags,
      _description,
      _process_mode,
      _status,
      _interactions,
      _io_mappings);
}

inline const ubii::sessions::Session *GetSession(const void *buf) {
  return flatbuffers::GetRoot<ubii::sessions::Session>(buf);
}

inline const ubii::sessions::Session *GetSizePrefixedSession(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ubii::sessions::Session>(buf);
}

inline bool VerifySessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ubii::sessions::Session>(nullptr);
}

inline bool VerifySizePrefixedSessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ubii::sessions::Session>(nullptr);
}

inline void FinishSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::sessions::Session> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::sessions::Session> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ubii::sessions::SessionT> UnPackSession(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ubii::sessions::SessionT>(GetSession(buf)->UnPack(res));
}

inline std::unique_ptr<ubii::sessions::SessionT> UnPackSizePrefixedSession(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ubii::sessions::SessionT>(GetSizePrefixedSession(buf)->UnPack(res));
}

}  // namespace sessions
}  // namespace ubii

#endif  // FLATBUFFERS_GENERATED_SESSION_UBII_SESSIONS_H_
