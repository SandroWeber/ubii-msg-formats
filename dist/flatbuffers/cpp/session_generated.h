// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SESSION_UBII_SESSIONS_H_
#define FLATBUFFERS_GENERATED_SESSION_UBII_SESSIONS_H_

#include "flatbuffers/flatbuffers.h"

#include "topicDemux_generated.h"
#include "topicMux_generated.h"
#include "interaction_generated.h"
#include "ioFormat_generated.h"
#include "interactionInputMapping_generated.h"
#include "interactionOutputMapping_generated.h"
#include "ioMapping_generated.h"

namespace ubii {
namespace sessions {

struct Session;

enum ProcessMode {
  ProcessMode_CYCLE_INTERACTIONS = 0,
  ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES = 1,
  ProcessMode_MIN = ProcessMode_CYCLE_INTERACTIONS,
  ProcessMode_MAX = ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES
};

inline const ProcessMode (&EnumValuesProcessMode())[2] {
  static const ProcessMode values[] = {
    ProcessMode_CYCLE_INTERACTIONS,
    ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES
  };
  return values;
}

inline const char * const *EnumNamesProcessMode() {
  static const char * const names[] = {
    "CYCLE_INTERACTIONS",
    "INDIVIDUAL_PROCESS_FREQUENCIES",
    nullptr
  };
  return names;
}

inline const char *EnumNameProcessMode(ProcessMode e) {
  if (e < ProcessMode_CYCLE_INTERACTIONS || e > ProcessMode_INDIVIDUAL_PROCESS_FREQUENCIES) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProcessMode()[index];
}

enum SessionStatus {
  SessionStatus_CREATED = 0,
  SessionStatus_RUNNING = 1,
  SessionStatus_PAUSED = 2,
  SessionStatus_STOPPED = 3,
  SessionStatus_MIN = SessionStatus_CREATED,
  SessionStatus_MAX = SessionStatus_STOPPED
};

inline const SessionStatus (&EnumValuesSessionStatus())[4] {
  static const SessionStatus values[] = {
    SessionStatus_CREATED,
    SessionStatus_RUNNING,
    SessionStatus_PAUSED,
    SessionStatus_STOPPED
  };
  return values;
}

inline const char * const *EnumNamesSessionStatus() {
  static const char * const names[] = {
    "CREATED",
    "RUNNING",
    "PAUSED",
    "STOPPED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSessionStatus(SessionStatus e) {
  if (e < SessionStatus_CREATED || e > SessionStatus_STOPPED) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSessionStatus()[index];
}

struct Session FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_AUTHORS = 8,
    VT_TAGS = 10,
    VT_DESCRIPTION = 12,
    VT_PROCESS_MODE = 14,
    VT_STATUS = 16,
    VT_INTERACTIONS = 18,
    VT_IO_MAPPINGS = 20
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *authors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_AUTHORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  ProcessMode process_mode() const {
    return static_cast<ProcessMode>(GetField<int8_t>(VT_PROCESS_MODE, 0));
  }
  SessionStatus status() const {
    return static_cast<SessionStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>> *interactions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>> *>(VT_INTERACTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<IOMapping>> *io_mappings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<IOMapping>> *>(VT_IO_MAPPINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_AUTHORS) &&
           verifier.VerifyVector(authors()) &&
           verifier.VerifyVectorOfStrings(authors()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<int8_t>(verifier, VT_PROCESS_MODE) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_INTERACTIONS) &&
           verifier.VerifyVector(interactions()) &&
           verifier.VerifyVectorOfTables(interactions()) &&
           VerifyOffset(verifier, VT_IO_MAPPINGS) &&
           verifier.VerifyVector(io_mappings()) &&
           verifier.VerifyVectorOfTables(io_mappings()) &&
           verifier.EndTable();
  }
};

struct SessionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Session::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Session::VT_NAME, name);
  }
  void add_authors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> authors) {
    fbb_.AddOffset(Session::VT_AUTHORS, authors);
  }
  void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
    fbb_.AddOffset(Session::VT_TAGS, tags);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Session::VT_DESCRIPTION, description);
  }
  void add_process_mode(ProcessMode process_mode) {
    fbb_.AddElement<int8_t>(Session::VT_PROCESS_MODE, static_cast<int8_t>(process_mode), 0);
  }
  void add_status(SessionStatus status) {
    fbb_.AddElement<int8_t>(Session::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_interactions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>>> interactions) {
    fbb_.AddOffset(Session::VT_INTERACTIONS, interactions);
  }
  void add_io_mappings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IOMapping>>> io_mappings) {
    fbb_.AddOffset(Session::VT_IO_MAPPINGS, io_mappings);
  }
  explicit SessionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SessionBuilder &operator=(const SessionBuilder &);
  flatbuffers::Offset<Session> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Session>(end);
    return o;
  }
};

inline flatbuffers::Offset<Session> CreateSession(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> authors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    ProcessMode process_mode = ProcessMode_CYCLE_INTERACTIONS,
    SessionStatus status = SessionStatus_CREATED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::interactions::Interaction>>> interactions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IOMapping>>> io_mappings = 0) {
  SessionBuilder builder_(_fbb);
  builder_.add_io_mappings(io_mappings);
  builder_.add_interactions(interactions);
  builder_.add_description(description);
  builder_.add_tags(tags);
  builder_.add_authors(authors);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_status(status);
  builder_.add_process_mode(process_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Session> CreateSessionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *authors = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tags = nullptr,
    const char *description = nullptr,
    ProcessMode process_mode = ProcessMode_CYCLE_INTERACTIONS,
    SessionStatus status = SessionStatus_CREATED,
    const std::vector<flatbuffers::Offset<ubii::interactions::Interaction>> *interactions = nullptr,
    const std::vector<flatbuffers::Offset<IOMapping>> *io_mappings = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto authors__ = authors ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*authors) : 0;
  auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto interactions__ = interactions ? _fbb.CreateVector<flatbuffers::Offset<ubii::interactions::Interaction>>(*interactions) : 0;
  auto io_mappings__ = io_mappings ? _fbb.CreateVector<flatbuffers::Offset<IOMapping>>(*io_mappings) : 0;
  return ubii::sessions::CreateSession(
      _fbb,
      id__,
      name__,
      authors__,
      tags__,
      description__,
      process_mode,
      status,
      interactions__,
      io_mappings__);
}

inline const ubii::sessions::Session *GetSession(const void *buf) {
  return flatbuffers::GetRoot<ubii::sessions::Session>(buf);
}

inline const ubii::sessions::Session *GetSizePrefixedSession(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ubii::sessions::Session>(buf);
}

inline bool VerifySessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ubii::sessions::Session>(nullptr);
}

inline bool VerifySizePrefixedSessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ubii::sessions::Session>(nullptr);
}

inline void FinishSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::sessions::Session> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::sessions::Session> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace sessions
}  // namespace ubii

#endif  // FLATBUFFERS_GENERATED_SESSION_UBII_SESSIONS_H_
