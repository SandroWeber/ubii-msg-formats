// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SERVER_UBII_SERVERS_H_
#define FLATBUFFERS_GENERATED_SERVER_UBII_SERVERS_H_

#include "flatbuffers/flatbuffers.h"

namespace ubii {
namespace servers {

struct Server;
struct ServerBuilder;
struct ServerT;

struct ServerT : public flatbuffers::NativeTable {
  typedef Server TableType;
  std::string id;
  std::string name;
  std::string ip_ethernet;
  std::string ip_wlan;
  std::string port_service_zmq;
  std::string port_service_rest;
  std::string port_topic_data_zmq;
  std::string port_topic_data_ws;
  std::string constants_json;
  ServerT() {
  }
};

struct Server FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerT NativeTableType;
  typedef ServerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_IP_ETHERNET = 8,
    VT_IP_WLAN = 10,
    VT_PORT_SERVICE_ZMQ = 12,
    VT_PORT_SERVICE_REST = 14,
    VT_PORT_TOPIC_DATA_ZMQ = 16,
    VT_PORT_TOPIC_DATA_WS = 18,
    VT_CONSTANTS_JSON = 20
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *ip_ethernet() const {
    return GetPointer<const flatbuffers::String *>(VT_IP_ETHERNET);
  }
  const flatbuffers::String *ip_wlan() const {
    return GetPointer<const flatbuffers::String *>(VT_IP_WLAN);
  }
  const flatbuffers::String *port_service_zmq() const {
    return GetPointer<const flatbuffers::String *>(VT_PORT_SERVICE_ZMQ);
  }
  const flatbuffers::String *port_service_rest() const {
    return GetPointer<const flatbuffers::String *>(VT_PORT_SERVICE_REST);
  }
  const flatbuffers::String *port_topic_data_zmq() const {
    return GetPointer<const flatbuffers::String *>(VT_PORT_TOPIC_DATA_ZMQ);
  }
  const flatbuffers::String *port_topic_data_ws() const {
    return GetPointer<const flatbuffers::String *>(VT_PORT_TOPIC_DATA_WS);
  }
  const flatbuffers::String *constants_json() const {
    return GetPointer<const flatbuffers::String *>(VT_CONSTANTS_JSON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_IP_ETHERNET) &&
           verifier.VerifyString(ip_ethernet()) &&
           VerifyOffset(verifier, VT_IP_WLAN) &&
           verifier.VerifyString(ip_wlan()) &&
           VerifyOffset(verifier, VT_PORT_SERVICE_ZMQ) &&
           verifier.VerifyString(port_service_zmq()) &&
           VerifyOffset(verifier, VT_PORT_SERVICE_REST) &&
           verifier.VerifyString(port_service_rest()) &&
           VerifyOffset(verifier, VT_PORT_TOPIC_DATA_ZMQ) &&
           verifier.VerifyString(port_topic_data_zmq()) &&
           VerifyOffset(verifier, VT_PORT_TOPIC_DATA_WS) &&
           verifier.VerifyString(port_topic_data_ws()) &&
           VerifyOffset(verifier, VT_CONSTANTS_JSON) &&
           verifier.VerifyString(constants_json()) &&
           verifier.EndTable();
  }
  ServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Server> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBuilder {
  typedef Server Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Server::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Server::VT_NAME, name);
  }
  void add_ip_ethernet(flatbuffers::Offset<flatbuffers::String> ip_ethernet) {
    fbb_.AddOffset(Server::VT_IP_ETHERNET, ip_ethernet);
  }
  void add_ip_wlan(flatbuffers::Offset<flatbuffers::String> ip_wlan) {
    fbb_.AddOffset(Server::VT_IP_WLAN, ip_wlan);
  }
  void add_port_service_zmq(flatbuffers::Offset<flatbuffers::String> port_service_zmq) {
    fbb_.AddOffset(Server::VT_PORT_SERVICE_ZMQ, port_service_zmq);
  }
  void add_port_service_rest(flatbuffers::Offset<flatbuffers::String> port_service_rest) {
    fbb_.AddOffset(Server::VT_PORT_SERVICE_REST, port_service_rest);
  }
  void add_port_topic_data_zmq(flatbuffers::Offset<flatbuffers::String> port_topic_data_zmq) {
    fbb_.AddOffset(Server::VT_PORT_TOPIC_DATA_ZMQ, port_topic_data_zmq);
  }
  void add_port_topic_data_ws(flatbuffers::Offset<flatbuffers::String> port_topic_data_ws) {
    fbb_.AddOffset(Server::VT_PORT_TOPIC_DATA_WS, port_topic_data_ws);
  }
  void add_constants_json(flatbuffers::Offset<flatbuffers::String> constants_json) {
    fbb_.AddOffset(Server::VT_CONSTANTS_JSON, constants_json);
  }
  explicit ServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerBuilder &operator=(const ServerBuilder &);
  flatbuffers::Offset<Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Server>(end);
    return o;
  }
};

inline flatbuffers::Offset<Server> CreateServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> ip_ethernet = 0,
    flatbuffers::Offset<flatbuffers::String> ip_wlan = 0,
    flatbuffers::Offset<flatbuffers::String> port_service_zmq = 0,
    flatbuffers::Offset<flatbuffers::String> port_service_rest = 0,
    flatbuffers::Offset<flatbuffers::String> port_topic_data_zmq = 0,
    flatbuffers::Offset<flatbuffers::String> port_topic_data_ws = 0,
    flatbuffers::Offset<flatbuffers::String> constants_json = 0) {
  ServerBuilder builder_(_fbb);
  builder_.add_constants_json(constants_json);
  builder_.add_port_topic_data_ws(port_topic_data_ws);
  builder_.add_port_topic_data_zmq(port_topic_data_zmq);
  builder_.add_port_service_rest(port_service_rest);
  builder_.add_port_service_zmq(port_service_zmq);
  builder_.add_ip_wlan(ip_wlan);
  builder_.add_ip_ethernet(ip_ethernet);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Server> CreateServerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const char *ip_ethernet = nullptr,
    const char *ip_wlan = nullptr,
    const char *port_service_zmq = nullptr,
    const char *port_service_rest = nullptr,
    const char *port_topic_data_zmq = nullptr,
    const char *port_topic_data_ws = nullptr,
    const char *constants_json = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto ip_ethernet__ = ip_ethernet ? _fbb.CreateString(ip_ethernet) : 0;
  auto ip_wlan__ = ip_wlan ? _fbb.CreateString(ip_wlan) : 0;
  auto port_service_zmq__ = port_service_zmq ? _fbb.CreateString(port_service_zmq) : 0;
  auto port_service_rest__ = port_service_rest ? _fbb.CreateString(port_service_rest) : 0;
  auto port_topic_data_zmq__ = port_topic_data_zmq ? _fbb.CreateString(port_topic_data_zmq) : 0;
  auto port_topic_data_ws__ = port_topic_data_ws ? _fbb.CreateString(port_topic_data_ws) : 0;
  auto constants_json__ = constants_json ? _fbb.CreateString(constants_json) : 0;
  return ubii::servers::CreateServer(
      _fbb,
      id__,
      name__,
      ip_ethernet__,
      ip_wlan__,
      port_service_zmq__,
      port_service_rest__,
      port_topic_data_zmq__,
      port_topic_data_ws__,
      constants_json__);
}

flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ServerT *Server::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<ubii::servers::ServerT> _o = std::unique_ptr<ubii::servers::ServerT>(new ServerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Server::UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = ip_ethernet(); if (_e) _o->ip_ethernet = _e->str(); }
  { auto _e = ip_wlan(); if (_e) _o->ip_wlan = _e->str(); }
  { auto _e = port_service_zmq(); if (_e) _o->port_service_zmq = _e->str(); }
  { auto _e = port_service_rest(); if (_e) _o->port_service_rest = _e->str(); }
  { auto _e = port_topic_data_zmq(); if (_e) _o->port_topic_data_zmq = _e->str(); }
  { auto _e = port_topic_data_ws(); if (_e) _o->port_topic_data_ws = _e->str(); }
  { auto _e = constants_json(); if (_e) _o->constants_json = _e->str(); }
}

inline flatbuffers::Offset<Server> Server::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _ip_ethernet = _o->ip_ethernet.empty() ? 0 : _fbb.CreateString(_o->ip_ethernet);
  auto _ip_wlan = _o->ip_wlan.empty() ? 0 : _fbb.CreateString(_o->ip_wlan);
  auto _port_service_zmq = _o->port_service_zmq.empty() ? 0 : _fbb.CreateString(_o->port_service_zmq);
  auto _port_service_rest = _o->port_service_rest.empty() ? 0 : _fbb.CreateString(_o->port_service_rest);
  auto _port_topic_data_zmq = _o->port_topic_data_zmq.empty() ? 0 : _fbb.CreateString(_o->port_topic_data_zmq);
  auto _port_topic_data_ws = _o->port_topic_data_ws.empty() ? 0 : _fbb.CreateString(_o->port_topic_data_ws);
  auto _constants_json = _o->constants_json.empty() ? 0 : _fbb.CreateString(_o->constants_json);
  return ubii::servers::CreateServer(
      _fbb,
      _id,
      _name,
      _ip_ethernet,
      _ip_wlan,
      _port_service_zmq,
      _port_service_rest,
      _port_topic_data_zmq,
      _port_topic_data_ws,
      _constants_json);
}

inline const ubii::servers::Server *GetServer(const void *buf) {
  return flatbuffers::GetRoot<ubii::servers::Server>(buf);
}

inline const ubii::servers::Server *GetSizePrefixedServer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ubii::servers::Server>(buf);
}

inline bool VerifyServerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ubii::servers::Server>(nullptr);
}

inline bool VerifySizePrefixedServerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ubii::servers::Server>(nullptr);
}

inline void FinishServerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::servers::Server> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedServerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::servers::Server> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ubii::servers::ServerT> UnPackServer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ubii::servers::ServerT>(GetServer(buf)->UnPack(res));
}

inline std::unique_ptr<ubii::servers::ServerT> UnPackSizePrefixedServer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ubii::servers::ServerT>(GetSizePrefixedServer(buf)->UnPack(res));
}

}  // namespace servers
}  // namespace ubii

#endif  // FLATBUFFERS_GENERATED_SERVER_UBII_SERVERS_H_
