// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEVICE_UBII_DEVICES_H_
#define FLATBUFFERS_GENERATED_DEVICE_UBII_DEVICES_H_

#include "flatbuffers/flatbuffers.h"

#include "component_generated.h"

namespace ubii {
namespace devices {

struct Device;
struct DeviceBuilder;
struct DeviceT;

enum DeviceType {
  DeviceType_PARTICIPANT = 0,
  DeviceType_WATCHER = 1,
  DeviceType_MIN = DeviceType_PARTICIPANT,
  DeviceType_MAX = DeviceType_WATCHER
};

inline const DeviceType (&EnumValuesDeviceType())[2] {
  static const DeviceType values[] = {
    DeviceType_PARTICIPANT,
    DeviceType_WATCHER
  };
  return values;
}

inline const char * const *EnumNamesDeviceType() {
  static const char * const names[3] = {
    "PARTICIPANT",
    "WATCHER",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceType(DeviceType e) {
  if (flatbuffers::IsOutRange(e, DeviceType_PARTICIPANT, DeviceType_WATCHER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeviceType()[index];
}

struct DeviceT : public flatbuffers::NativeTable {
  typedef Device TableType;
  std::string id;
  std::string name;
  std::vector<std::string> tags;
  std::string description;
  std::string client_id;
  ubii::devices::DeviceType device_type;
  std::vector<std::unique_ptr<ubii::devices::ComponentT>> components;
  DeviceT()
      : device_type(ubii::devices::DeviceType_PARTICIPANT) {
  }
};

struct Device FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceT NativeTableType;
  typedef DeviceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TAGS = 8,
    VT_DESCRIPTION = 10,
    VT_CLIENT_ID = 12,
    VT_DEVICE_TYPE = 14,
    VT_COMPONENTS = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::String *client_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_ID);
  }
  ubii::devices::DeviceType device_type() const {
    return static_cast<ubii::devices::DeviceType>(GetField<int8_t>(VT_DEVICE_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<ubii::devices::Component>> *components() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ubii::devices::Component>> *>(VT_COMPONENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyField<int8_t>(verifier, VT_DEVICE_TYPE) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(components()) &&
           verifier.VerifyVectorOfTables(components()) &&
           verifier.EndTable();
  }
  DeviceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeviceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Device> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeviceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeviceBuilder {
  typedef Device Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Device::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Device::VT_NAME, name);
  }
  void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
    fbb_.AddOffset(Device::VT_TAGS, tags);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Device::VT_DESCRIPTION, description);
  }
  void add_client_id(flatbuffers::Offset<flatbuffers::String> client_id) {
    fbb_.AddOffset(Device::VT_CLIENT_ID, client_id);
  }
  void add_device_type(ubii::devices::DeviceType device_type) {
    fbb_.AddElement<int8_t>(Device::VT_DEVICE_TYPE, static_cast<int8_t>(device_type), 0);
  }
  void add_components(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::devices::Component>>> components) {
    fbb_.AddOffset(Device::VT_COMPONENTS, components);
  }
  explicit DeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceBuilder &operator=(const DeviceBuilder &);
  flatbuffers::Offset<Device> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Device>(end);
    return o;
  }
};

inline flatbuffers::Offset<Device> CreateDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::String> client_id = 0,
    ubii::devices::DeviceType device_type = ubii::devices::DeviceType_PARTICIPANT,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ubii::devices::Component>>> components = 0) {
  DeviceBuilder builder_(_fbb);
  builder_.add_components(components);
  builder_.add_client_id(client_id);
  builder_.add_description(description);
  builder_.add_tags(tags);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_device_type(device_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Device> CreateDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tags = nullptr,
    const char *description = nullptr,
    const char *client_id = nullptr,
    ubii::devices::DeviceType device_type = ubii::devices::DeviceType_PARTICIPANT,
    const std::vector<flatbuffers::Offset<ubii::devices::Component>> *components = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  auto components__ = components ? _fbb.CreateVector<flatbuffers::Offset<ubii::devices::Component>>(*components) : 0;
  return ubii::devices::CreateDevice(
      _fbb,
      id__,
      name__,
      tags__,
      description__,
      client_id__,
      device_type,
      components__);
}

flatbuffers::Offset<Device> CreateDevice(flatbuffers::FlatBufferBuilder &_fbb, const DeviceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline DeviceT *Device::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<ubii::devices::DeviceT> _o = std::unique_ptr<ubii::devices::DeviceT>(new DeviceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Device::UnPackTo(DeviceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = tags(); if (_e) { _o->tags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tags[_i] = _e->Get(_i)->str(); } } }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = device_type(); _o->device_type = _e; }
  { auto _e = components(); if (_e) { _o->components.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->components[_i] = std::unique_ptr<ubii::devices::ComponentT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Device> Device::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeviceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDevice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Device> CreateDevice(flatbuffers::FlatBufferBuilder &_fbb, const DeviceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DeviceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _tags = _o->tags.size() ? _fbb.CreateVectorOfStrings(_o->tags) : 0;
  auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _device_type = _o->device_type;
  auto _components = _o->components.size() ? _fbb.CreateVector<flatbuffers::Offset<ubii::devices::Component>> (_o->components.size(), [](size_t i, _VectorArgs *__va) { return CreateComponent(*__va->__fbb, __va->__o->components[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ubii::devices::CreateDevice(
      _fbb,
      _id,
      _name,
      _tags,
      _description,
      _client_id,
      _device_type,
      _components);
}

inline const ubii::devices::Device *GetDevice(const void *buf) {
  return flatbuffers::GetRoot<ubii::devices::Device>(buf);
}

inline const ubii::devices::Device *GetSizePrefixedDevice(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ubii::devices::Device>(buf);
}

inline bool VerifyDeviceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ubii::devices::Device>(nullptr);
}

inline bool VerifySizePrefixedDeviceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ubii::devices::Device>(nullptr);
}

inline void FinishDeviceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::devices::Device> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDeviceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ubii::devices::Device> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ubii::devices::DeviceT> UnPackDevice(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ubii::devices::DeviceT>(GetDevice(buf)->UnPack(res));
}

inline std::unique_ptr<ubii::devices::DeviceT> UnPackSizePrefixedDevice(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ubii::devices::DeviceT>(GetSizePrefixedDevice(buf)->UnPack(res));
}

}  // namespace devices
}  // namespace ubii

#endif  // FLATBUFFERS_GENERATED_DEVICE_UBII_DEVICES_H_
